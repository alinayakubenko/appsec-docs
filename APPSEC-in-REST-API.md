
# Cheat Sheet on APPSEC in REST API

1. Cover/mask the sensitive data, like account number, ssn, etc. Looking at the value it shouldn't be possible to understand what kind of data this is.
2. the encryption is used and endpoints are running over HTTPS. The server is only has TLSv1.2. Verify that backend TLS connection failures are logged.
3. JWT is used and mandatory. Any request with  HTTP_AUTH value except valid JWT token returns 401/Unauthorized  
4. JWT token is updated every 15 minutes/rate limit is added.
5. White list for HTTP methods. Only defined method should be successfully used for submitting request. If request is supposed to be send as POST it shouldn't be possible to submit it with GET, or any other method type. Whenever transmitting sensitive data always do this by means of the POST request or by header. Note: Avoid user input in your application header, this could lead to vulnerabilities. Also make sure you disable all other HTTP request methods which are unnecessary for your applications operation such as; REST, PUT, TRACE, DELETE, OPTIONS, etc, since allowing these request methods could lead to vulnerabilities and injections.
6. The Error messages don't contain any information about the environment and they are not descriptive. The error messages should be custom and do not disclose unnecessary information. Example of secure error message is "Error: Invalid combination of inputs". 
7. Verify that there is a single application level logging implementation that is used by the software.
8. Verify all the user input has been limited and the application only accepts expected input lengths. The special characters such as !@#$%^&*()<> must not be allowed. To ensure that the application is robust against all forms of input data, this data should be sanitized and/or encoded on serverside since an attacker could otherwise easy bypass these checks with an intercepting proxy.  ll input validation and encoding routines should be implemented on the serverside outside the reach of an attacker. Just as with the input rejection you should make sure that after validating the user input, whenever the input is bad it actually rejects, sanitizes or formats your user input into not malicious data. The recommended method for validating user input would be the positive validation method. Whitelist input validation means allowing only input that is explicitly defined as valid, as opposed to blacklist input validation, which filters out known bad input.
Verify that a single input validation control is used by the application for each type of data that is accepted. This way your validation controls stay clear, transparent and manageable. This method leaves less room for error.
9. Set the content type headers.
10. Verify that the HTTP headers do not expose detailed version information of system components. For each different type of server, there are hardening guides dedicated especially for this type of data leaking. The same applies for i.e any other leak of version information such as the version of your programming language or other services running to make your application function.
11. Verify that logging is performed before executing the transaction. If logging was unsuccessful (e.g. disk full, insufficient permissions) the application fails safe. This is for when integrity and nonrepudiation is a must. Logs in code shouldn't use variables.
12. All SQL queries, HQL, OSQL, NOSQL and stored procedures, related to stored procedures should be protected by the use of query parameterization.
13. Make sure all your security settings in your development framework are set to secure values. This can be checked by using hardening guides.	
14. Sensitive information stored alongside the source code. Search your source code for comments which contains possible user credentials. You should also verify that there are no secrets and API keys are included in the source code, or end up within the resulting binary. The configuration files shouldn't also store any sensitive information.
15. Personally Identifiable Information needs to be stored encrypted at rest and ensure that all communication goes via protected channels like SSL/TLS.
16. Verify that all application components, libraries, modules, frameworks, platform, and operating systems are free from known vulnerabilities.
17. Malicious intent. Before pushing a code live you should check the software for malicious code in order to make sure no developers with evil intent made backdoors or deliberately put in exploits. Dependencies and third party libraries should also be validated against malicious code. These dependencies and libraries should also be validated for known vulnerabilities (CVE)  Solution: Running your code through a static code analyzer or auditing tools could give you a chance to find malicious pieces of code which could be embedded into the software. Also if the new or adjusted functionality is critical then check manually it in the form of a code review for back doors, Easter eggs, and logic flaws. This should also mean that authorized administrators must have the capability to verify the integrity of all security relevant configurations to ensure that they have not been tampered with. Determine also that the business logic of high value transactions is not imported from untrusted third party libraries.  Note: Studies have shown backdoors written by employees with malicious intend will probably do this within the first half year of their employment. The implementing of back doors has little to do with how happy an employee is with the current employer, it has proven to be a trait of character rather than a trait of discontent.

